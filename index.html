<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>진격의 인간 (나는 모기)</title>
  <style>
    body { margin:0; overflow:hidden; background:#222; color:#fff; font-family:sans-serif; }
    /* 기본적으로 마우스 커서를 보이게 하고, 게임 시작 시에만 숨깁니다. */
    .hide-cursor { cursor: none; } 

    #ui { position:absolute; top:10px; left:10px; z-index:10; }
    #ui select, #ui button { font-size:16px; margin-right:10px; }
  </style>
</head>
<body>
  <div id="ui">
    <select id="charSelect">
      <option value="levi">강철 모기 (리바이)</option>
      <option value="eren">돌진 모기 (에렌)</option>
    </select>
    <button id="startBtn">게임 시작</button>
    <span id="score">점수: 0</span>
  </div>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx    = canvas.getContext('2d');
    let W, H;

    function resize() {
      W = canvas.width = innerWidth;
      H = canvas.height = innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    let mouseX = W / 2;
    let mouseY = H / 2;

    window.addEventListener('mousemove', e => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    let player, enemies, score, running;

    class Player {
      constructor(x,y, color) {
        this.x = x; this.y = y;
        this.width = 15;
        this.height = 30;
        this.color = color;
      }
      update() {
        this.x = mouseX;
        this.y = mouseY;

        this.x = Math.max(this.width / 2, Math.min(W - this.width / 2, this.x));
        this.y = Math.max(this.height / 2, Math.min(H - this.height / 2, this.y));
      }
      draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.ellipse(this.x, this.y, this.width / 2, this.height / 2, Math.PI / 4, 0, Math.PI * 2);
        ctx.fill();

        ctx.beginPath();
        ctx.arc(this.x + Math.cos(Math.PI / 4) * (this.height / 2 - 5), 
                this.y + Math.sin(Math.PI / 4) * (this.height / 2 - 5), 
                5, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = this.color;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x - 10, this.y - 20);
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + 10, this.y - 20);
        ctx.stroke();
      }
    }

    class Enemy { 
      constructor() { this.reset(); }
      reset() {
        const edge = Math.random() * 4 | 0;
        if (edge === 0) { this.x = -50;       this.y = Math.random()*H; }
        if (edge === 1) { this.x = W + 50;    this.y = Math.random()*H; }
        if (edge === 2) { this.x = Math.random()*W; this.y = -50; }
        if (edge === 3) { this.x = Math.random()*W; this.y = H + 50; }

        this.size  = 25;
        // 인간 속도 증가: 2.5 (최소) + 2.5 (랜덤 추가) = 최대 5.0
        this.speed = 2.5 + Math.random()*2.5; 
        this.vx = this.vy = 0;
      }
      update() {
        if (!this.vx && !this.vy) {
          const dx = player.x - this.x;
          const dy = player.y - this.y;
          const d = Math.hypot(dx, dy);
          this.vx = dx/d * this.speed;
          this.vy = dy/d * this.speed;
        }
        this.x += this.vx;
        this.y += this.vy;

        if (this.x < -100 || this.x > W+100 || this.y < -100 || this.y > H+100) {
          this.reset();
        }
      }
      draw() {
        ctx.strokeStyle = 'rgba(200,0,0,0.7)';
        ctx.lineWidth = 3;

        ctx.beginPath();
        ctx.arc(this.x, this.y - this.size * 0.5, this.size * 0.5, 0, Math.PI * 2);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x, this.y + this.size);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(this.x, this.y + this.size * 0.2);
        ctx.lineTo(this.x - this.size * 0.7, this.y + this.size * 0.7);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(this.x, this.y + this.size * 0.2);
        ctx.lineTo(this.x + this.size * 0.7, this.y + this.size * 0.7);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(this.x, this.y + this.size);
        ctx.lineTo(this.x - this.size * 0.5, this.y + this.size * 1.5);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(this.x, this.y + this.size);
        ctx.lineTo(this.x + this.size * 0.5, this.y + this.size * 1.5);
        ctx.stroke();
      }
      hits(p) {
        const dx = this.x - p.x;
        const dy = (this.y + this.size * 0.75) - p.y;
        const distance = Math.hypot(dx, dy);
        
        return distance < (this.size * 1.2) + (p.width / 2); 
      }
    }

    function initGame() {
      document.body.classList.add('hide-cursor');

      // 인간 생성 개수 증가: 3 -> 7
      enemies = Array.from({length:7}, () => new Enemy()); 
      score   = 0;
      running = true;
      const choice = document.getElementById('charSelect').value;
      const color  = (choice === 'levi' ? '#a0f' : '#0fa');
      player = new Player(W/2, H/2, color);
      document.getElementById('score').textContent = '점수: 0';
      requestAnimationFrame(loop);
    }

    function loop() {
      if (!running) {
        document.body.classList.remove('hide-cursor');
        return;
      }
      player.update();
      enemies.forEach(a => a.update());

      if (enemies.some(a => a.hits(player))) {
        running = false;
        alert('인간에게 잡혔다! 최종 생존 시간: ' + score + '초');
        return;
      }
      ctx.clearRect(0,0,W,H);
      player.draw();
      enemies.forEach(a => a.draw());

      score++;
      document.getElementById('score').textContent = '점수: ' + score;
      requestAnimationFrame(loop);
    }

    document.getElementById('startBtn').addEventListener('click', initGame);
  </script>
</body>
</html>
